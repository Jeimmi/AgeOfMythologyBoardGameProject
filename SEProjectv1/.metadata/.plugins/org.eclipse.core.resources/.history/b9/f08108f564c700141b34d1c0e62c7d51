/**
 * @author Lyndon Kondratczyk
 * @version 3/9/15
 * 
 * The template for an AoM Build Card attributes
 */
import java.awt.image.BufferedImage;
import java.util.ArrayList;

public class BuildCard extends Card {
	
	/**
     * The constructor for creating a Build Card with image
     * 
     * @param front The Card's front image
     * @param back The Card's back image
     * @param permanent True if Card is permanent
     * @param name The Card name
     * @param firstDescription The main Card description
     * @param secondDescription The secondary Card description
     * @param value The max number of builds
     * @param cost The cost to play the Card
     */
	public BuildCard(BufferedImage front, BufferedImage back,
			boolean permanent, String firstDescription,
			String secondDescription, int value, int cost) {
		super(front, back, permanent, "Build", firstDescription,
				secondDescription, value, cost);
	}
	
	/**
	 * This function creates a list of buildings a player can build
	 * given his available building, wallet and discounts
	 * 
	 * @param player The player playing the BuildCard
	 * @param discount The player's applicable discount
	 * 
	 * @return A list of build options for the player
	 */
/*	public ArrayList<Building> populateAffordable(Player player, int discount) {
		ArrayList<Building> affordable = new ArrayList<Building>();
		ArrayList<Building> toCheck = new ArrayList<Building>();
		
		for(int i = 0; i < player.buildingPool.size(); i++){
			if(!(toCheck.contains(player.buildingPool.get(i)))){
				toCheck.add(player.buildingPool.get(i));
			} 
		}
		
		ArrayList<Building> tempList = new ArrayList<Building>();
		Building tempBuilding;
		for(int i = 0; i < discount; i++){
			for(int j = toCheck.size() - 1; j >= 0; j++){
				tempBuilding = new Building(toCheck.get(j));
				for(int k = 0; k < 4; k++){
					tempList.add((tempBuilding.reduce(tempBuilding, k)));
				}
			}
			discount --;
		}
		toCheck = tempList;
		
		for(int i = 0; i < toCheck.size(); i++){
			if(canAfford(player, toCheck.get(i)) && !(affordable.contains(toCheck.get(i)))){
				affordable.add(toCheck.get(i));
			}
		}
		
		return affordable;
	}
	
	public ArrayList<Building> populateAffordableByArray(Player player, Building building){
		ArrayList<Building> affordable = new ArrayList<Building>();
		boolean houseAdded = false;
		for(int i = 0; i < player.buildingPool.size(); i++){
			if((houseAdded) && (affordable.contains(Building.Type.HOUSE)){
				
			}
		}
		return affordable;
	}*/
	
/*	*//**
	 * Checks to see if a player can afford a building
	 * 
	 * @param player The player playing the Build Card
	 * @param building The Building to check
	 * 
	 * @return True if the Player can afford the Building
	 *//*
	public boolean canAfford(Player player, Building building){
		for(int i = 0; i < 4; i++){
			if(player.wallet[i] < building.cost[i]){
				return false;
			}
		}
		return true;
	}*/
	
	public boolean canAffordByResource(int[] wallet, int[] cost){
		for(int i = 0; i < 4; i++){
			if(wallet[i] < cost[i]){
				return false;
			}
		}
		return true;
	}
	
	public boolean canAffordWithDiscount(int[] wallet, int[] cost, int discount, int index){
		if(canAffordByResource(wallet, cost)){
			return true;
		}
		else if((discount) > 0 && index == 4){
			return canAffordWithDiscount(wallet, cost, discount - 1, 0);
		}
		else if(discount > 0){
			return canAffordWithDiscount(wallet, cost, discount, index + 1);
		}
		else{
			return false;
		}
		
	}
	
	public ArrayList<Building> populateAffordable(Player player, int discount){
		ArrayList<Building> affordable = new ArrayList<Building>();
		int copyDiscount = 0 + discount;
		boolean houseChecked = false;
		
		for(int i = 0; i < player.city.size(); i++){
			if((player.city.get(i)).type == Building.Type.QUARRY){
				discount = 1;
				System.out.println("DISCOUNT APPLIED");
			}
		}
		for(int i = 0; i < player.buildingPool.size(); i++){
			Building temp = player.buildingPool.get(i);
			int[] copyCost = new int[4];
			for(int j = 0; j < 4; j++){
				copyCost[j] = temp.cost[j];
			}
			if(!(houseChecked)){
				if(temp.type == Building.Type.HOUSE){
					houseChecked = true;
				}
				if(canAffordWithDiscount(player.wallet, copyCost, copyDiscount, 0)){
					affordable.add(temp);
				}
			}
		}
		return affordable;
	}
	
	public int buildBuilding(Game game, Building selection, int[] refundOptions){
		int discountUsed = 0;
		for(int i = 0; i < 4; i ++){
			if(game.activePlayer.wallet[i] < selection.cost[i]){
				int temp = selection.cost[i] - game.activePlayer.wallet[i];
				discountUsed = discountUsed + temp;
				game.activePlayer.wallet[i] = 0;
				game.bank[i] = game.bank[i] + selection.cost[i] - discountUsed;
				refundOptions[i] = refundOptions[i] + selection.cost[i] - discountUsed;
			}
			else{
				game.activePlayer.wallet[i] = game.activePlayer.wallet[i] - selection.cost[i];
				game.bank[i] = game.bank[i] + selection.cost[i];
				refundOptions[i] = refundOptions[i] + selection.cost[i];
			}
		}
		addBuilding(game, selection);
		return discountUsed;
	}
	
	
	
	/**
	 * This method executes a sequence of events in the Game that represent
	 * playing a BuildCard
	 * 
	 * @param game The Game being worked on by the Card
	 */
	
	@Override
	public void execute(Game game) {
		UserInterface<Building> buildingSelect = new UserInterface<Building>();
		UserInterface<String> refundSelect = new UserInterface<String>(); 
		ArrayList<String> resources = new ArrayList<String>();
		resources.add("food");
		resources.add("wood");
		resources.add("gold");
		resources.add("favor");
		int discount = 0;
		for(int i = 0; i < game.activePlayer.city.size(); i++){
			if((game.activePlayer.city.get(i)).type == Building.Type.QUARRY){
				discount = 1;
			}
		}
		int builds = value;
		
		for(int i = 0; i < builds; i++){
			int[] refundAvailable = {0, 0, 0, 0};
			int discountUsed = 0;
			ArrayList<Building> options = populateAffordable(game.activePlayer, discount);
			buildingSelect.provideMenuOptions("Please select a building to build from the following:", 
					game.activePlayer, options, "Pass remainder of turn");
			Building selection = buildingSelect.getPlayerSelection(game.activePlayer, options, true);
			if(selection == null){
				i = builds;
			}
			else{
				discountUsed = discountUsed + buildBuilding(game, selection, refundAvailable);
			}
			for(int j = 0; j < discount - discountUsed; j++){
				ArrayList<String> refundOptions = new ArrayList<String>();
				for(int k = 0; k < 4; k++){
					if(refundAvailable[k] > 0){
						refundOptions.add(resources.get(k));
					}
					refundSelect.provideMenuOptions("Select a refund: ", game.activePlayer,
							refundOptions, null);
					String refund = refundSelect.getPlayerSelection(
							game.activePlayer, refundOptions, false);
					switch(refund){
					case("food"):
						game.activePlayer.wallet[0] += 1;
						refundAvailable[0] -= 1;
						break;
					case("wood"):
						game.activePlayer.wallet[1] += 1;
						refundAvailable[1] -= 1;
						break;
					case("gold"):
						game.activePlayer.wallet[2] += 1;
						refundAvailable[2] -= 1;
						break;
					case("favor"):
						game.activePlayer.wallet[3] += 1;
						refundAvailable[3] -= 1;
						break;
				}
				
			}
		}		
		// TODO Auto-generated method stub
	}
}